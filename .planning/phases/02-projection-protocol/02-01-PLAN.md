---
phase: 02-projection-protocol
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/aquacore/projection/protocol.py
  - src/aquacore/projection/refractive.py
  - src/aquacore/projection/__init__.py
  - src/aquacore/__init__.py
autonomous: true
must_haves:
  truths:
    - "ProjectionModel protocol defines project() and back_project() with correct signatures"
    - "RefractiveProjectionModel can be constructed from raw tensors and from Phase 1 typed objects"
    - "project() returns (pixels, valid_mask) for underwater 3D points"
    - "back_project() returns (origins, directions) for pixel coordinates"
    - "project_multi and back_project_multi produce (M, N, ...) stacked outputs"
    - "isinstance(RefractiveProjectionModel(...), ProjectionModel) returns True at runtime"
  artifacts:
    - path: "src/aquacore/projection/protocol.py"
      provides: "@runtime_checkable ProjectionModel Protocol"
      contains: "class ProjectionModel"
    - path: "src/aquacore/projection/refractive.py"
      provides: "RefractiveProjectionModel + multi-camera helpers"
      exports: ["RefractiveProjectionModel", "project_multi", "back_project_multi"]
    - path: "src/aquacore/projection/__init__.py"
      provides: "Subpackage exports"
      exports: ["ProjectionModel", "RefractiveProjectionModel", "project_multi", "back_project_multi"]
  key_links:
    - from: "src/aquacore/projection/refractive.py"
      to: "src/aquacore/refraction.py"
      via: "refractive_project() delegation in project()"
      pattern: "refractive_project"
    - from: "src/aquacore/projection/refractive.py"
      to: "src/aquacore/types.py"
      via: "InterfaceParams in from_camera()"
      pattern: "InterfaceParams"
    - from: "src/aquacore/__init__.py"
      to: "src/aquacore/projection/__init__.py"
      via: "re-export projection public API"
      pattern: "from .projection import"
---

<objective>
Implement the ProjectionModel protocol and RefractiveProjectionModel class with forward projection, back-projection, factory method, device transfer, and multi-camera helpers.

Purpose: This is the refractive projection layer that wraps Phase 1's physics primitives into a stateful, per-camera model — the core public API for projecting underwater points to pixels and casting rays from pixels into water.

Output: Four production source files (protocol.py, refractive.py, projection/__init__.py updated, aquacore/__init__.py updated) ready for testing.
</objective>

<execution_context>
@C:/Users/tucke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/tucke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-projection-protocol/02-RESEARCH.md
@src/aquacore/refraction.py
@src/aquacore/types.py
@src/aquacore/camera.py
@src/aquacore/__init__.py
@src/aquacore/projection/__init__.py
@src/aquacore/projection/protocol.py
@src/aquacore/projection/refractive.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ProjectionModel protocol and RefractiveProjectionModel class</name>
  <files>
    src/aquacore/projection/protocol.py
    src/aquacore/projection/refractive.py
  </files>
  <action>
**protocol.py:** Create `@runtime_checkable` `ProjectionModel(Protocol)` with two methods:
- `project(self, points: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor]` — (N,3) world points to (N,2) pixels + (N,) bool valid mask. Docstring: invalid pixels are NaN.
- `back_project(self, pixels: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor]` — (N,2) pixels to (N,3) origins on water surface + (N,3) unit directions into water.

Use `from typing import Protocol, runtime_checkable`. Import torch. Google-style docstrings describing shapes and semantics. Method bodies are `...` (ellipsis).

**refractive.py:** Implement `RefractiveProjectionModel` class:

**Constructor `__init__(self, K, R, t, water_z, normal, n_air, n_water)`:**
- Store all params as attributes. K: (3,3) float32, R: (3,3) float32, t: (3,) float32, water_z: float, normal: (3,) float32, n_air: float, n_water: float.
- Precompute and cache: `self.K_inv = torch.linalg.inv(K)`, `self.C = -R.T @ t` (camera center), `self.n_ratio = n_air / n_water`.

**`from_camera(cls, camera, interface)` classmethod:**
- Parameter `camera` typed as `Any` (Phase 1 camera classes are private but expose K, R, t as plain attributes). Docstring documents required attributes.
- Parameter `interface` typed as `InterfaceParams`.
- Extracts `camera.K`, `camera.R`, `camera.t`, `interface.water_z`, `interface.normal`, `interface.n_air`, `interface.n_water` and delegates to `cls(...)`.

**`to(self, device)` method:**
- Moves K, K_inv, R, t, C, normal to target device. n_air, n_water, n_ratio, water_z are Python floats — no device transfer needed.
- Returns `self` (mutable in-place, matching AquaMVS + PyTorch convention).

**`project(self, points)` method:**
- Delegates to Phase 1 `refractive_project(points, self.C, interface)` to find interface point P. Construct a temporary `InterfaceParams(normal=self.normal, water_z=self.water_z, n_air=self.n_air, n_water=self.n_water)`.
- Project P through undistorted pinhole: `p_cam = (self.R @ P.T).T + self.t.unsqueeze(0)`, then `p_norm = p_cam[:, :2] / p_cam[:, 2:3]`, then `pixels = (self.K[:2, :2] @ p_norm.T).T + self.K[:2, 2].unsqueeze(0)`.
- Validity: `(h_q > 0) & (p_cam[:, 2] > 0)` where `h_q = points[:, 2] - self.water_z`.
- Invalid pixels set to NaN via `torch.where(valid.unsqueeze(-1), pixels, torch.tensor(float("nan"), ...))`.
- Returns `(pixels, valid)`.

**`back_project(self, pixels)` method — inline Snell's law (per research recommendation):**
- Convert pixels to homogeneous: `pixels_h = torch.cat([pixels, ones], dim=-1)`.
- Camera-frame rays: `rays_cam = (self.K_inv @ pixels_h.T).T`, normalize.
- World-frame rays: `rays_world = (self.R.T @ rays_cam.T).T`.
- Ray-plane intersection at Z=water_z: `t_param = (self.water_z - self.C[2]) / rays_world[:, 2]`, `origins = self.C.unsqueeze(0) + t_param.unsqueeze(-1) * rays_world`.
- Inline Snell's law (air to water): `cos_i = -(rays_world * self.normal).sum(dim=-1)`, `sin_t_sq = self.n_ratio**2 * (1.0 - cos_i**2)`, `cos_t = sqrt(clamp(1-sin_t_sq, min=0))`, vector form refraction, normalize.
- Returns `(origins, directions)` — no valid_mask (air-to-water TIR is physically impossible per research).

**Multi-camera helpers** (module-level functions in refractive.py):
- `project_multi(models: list[RefractiveProjectionModel], points: Tensor) -> tuple[Tensor, Tensor]` — loop over models, stack into (M, N, 2) pixels + (M, N) valid.
- `back_project_multi(models: list[RefractiveProjectionModel], pixels: Tensor) -> tuple[Tensor, Tensor]` — loop over models, stack into (M, N, 3) origins + (M, N, 3) directions.

All operations use non-in-place ops for autograd safety. Follow Google-style docstrings with tensor shapes.
  </action>
  <verify>
Run `hatch run check` (lint + typecheck). Verify:
- No ruff lint errors in protocol.py or refractive.py
- basedpyright passes (no type errors)
- `python -c "from aquacore.projection import ProjectionModel, RefractiveProjectionModel, project_multi, back_project_multi; print('imports OK')"` succeeds
  </verify>
  <done>
protocol.py defines @runtime_checkable ProjectionModel with project() and back_project(). refractive.py defines RefractiveProjectionModel with __init__, from_camera, to, project, back_project, plus project_multi and back_project_multi module functions. All pass lint and typecheck.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update package exports</name>
  <files>
    src/aquacore/projection/__init__.py
    src/aquacore/__init__.py
  </files>
  <action>
**projection/__init__.py:** Replace stub content with proper exports:
```python
from .protocol import ProjectionModel
from .refractive import (
    RefractiveProjectionModel,
    back_project_multi,
    project_multi,
)

__all__ = [
    "ProjectionModel",
    "RefractiveProjectionModel",
    "back_project_multi",
    "project_multi",
]
```

**aquacore/__init__.py:** Add projection imports. Insert `from .projection import (ProjectionModel, RefractiveProjectionModel, back_project_multi, project_multi)` in the import block (after refraction imports). Add all four names to `__all__` in sorted position. Keep existing exports unchanged.
  </action>
  <verify>
Run `python -c "from aquacore import ProjectionModel, RefractiveProjectionModel, project_multi, back_project_multi; print('top-level imports OK')"`.
Run `hatch run lint` to confirm no import ordering issues.
  </verify>
  <done>
ProjectionModel, RefractiveProjectionModel, project_multi, and back_project_multi are importable from both `aquacore.projection` and `aquacore` top-level. __all__ lists are complete and sorted.
  </done>
</task>

</tasks>

<verification>
1. `hatch run check` passes (lint + typecheck) with no errors in projection/ files
2. `python -c "from aquacore import ProjectionModel, RefractiveProjectionModel; import torch; print(isinstance(RefractiveProjectionModel, type))"` prints True
3. All existing tests still pass: `hatch run test`
</verification>

<success_criteria>
- ProjectionModel protocol is @runtime_checkable with project() and back_project() signatures
- RefractiveProjectionModel implements constructor, from_camera, to, project, back_project
- project() delegates Newton-Raphson to Phase 1 refractive_project()
- back_project() inlines Snell's law (AquaMVS pattern)
- Multi-camera helpers project_multi and back_project_multi exist
- All names exported from aquacore.projection and aquacore top-level
- Lint and typecheck pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-projection-protocol/02-01-SUMMARY.md`
</output>
