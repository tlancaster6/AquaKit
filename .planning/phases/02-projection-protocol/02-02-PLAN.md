---
phase: 02-projection-protocol
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - tests/unit/test_projection/__init__.py
  - tests/unit/test_projection/test_protocol.py
  - tests/unit/test_projection/test_refractive.py
autonomous: true
must_haves:
  truths:
    - "isinstance(RefractiveProjectionModel(...), ProjectionModel) returns True"
    - "A dummy class with project() and back_project() satisfies ProjectionModel"
    - "A class missing back_project() does NOT satisfy ProjectionModel"
    - "project() output matches Phase 1 refractive_project pinhole projection to floating-point tolerance"
    - "Round-trip project then back_project recovers original 3D point within 1e-4"
    - "Newton-Raphson residual f(r_p_final) is below 1e-6 after 10 iterations"
    - "Batched inputs (N>1 points) produce correctly shaped outputs"
    - "project_multi with M models produces (M, N, 2) pixels and (M, N) valid"
    - "back_project_multi with M models produces (M, N, 3) origins and (M, N, 3) directions"
    - "All tests pass on CPU; CUDA tests parametrized and skip cleanly without GPU"
    - "from_camera() factory produces identical results to raw-tensor constructor"
    - ".to(device) moves all tensors and returns self"
  artifacts:
    - path: "tests/unit/test_projection/__init__.py"
      provides: "Test package marker"
    - path: "tests/unit/test_projection/test_protocol.py"
      provides: "Protocol compliance tests (positive + negative)"
      min_lines: 30
    - path: "tests/unit/test_projection/test_refractive.py"
      provides: "RefractiveProjectionModel functional tests"
      min_lines: 120
  key_links:
    - from: "tests/unit/test_projection/test_refractive.py"
      to: "src/aquacore/projection/refractive.py"
      via: "import and construct RefractiveProjectionModel"
      pattern: "RefractiveProjectionModel"
    - from: "tests/unit/test_projection/test_protocol.py"
      to: "src/aquacore/projection/protocol.py"
      via: "isinstance check against ProjectionModel"
      pattern: "isinstance.*ProjectionModel"
---

<objective>
Write comprehensive tests for the ProjectionModel protocol and RefractiveProjectionModel, covering all four phase success criteria: protocol compliance, round-trip convergence, batched operations, and type-checking.

Purpose: These tests prove correctness of the projection layer against known physics — round-trip consistency, Newton-Raphson convergence residuals, shape contracts for batched/multi-camera operations, and structural protocol compliance.

Output: Test files in tests/unit/test_projection/ that pass on CPU (CUDA-parametrized, skip without GPU).
</objective>

<execution_context>
@C:/Users/tucke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/tucke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-projection-protocol/02-RESEARCH.md
@.planning/phases/02-projection-protocol/02-01-SUMMARY.md
@src/aquacore/projection/protocol.py
@src/aquacore/projection/refractive.py
@src/aquacore/refraction.py
@src/aquacore/types.py
@src/aquacore/camera.py
@tests/conftest.py
@tests/unit/test_refraction.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Protocol compliance tests</name>
  <files>
    tests/unit/test_projection/__init__.py
    tests/unit/test_projection/test_protocol.py
  </files>
  <action>
Create `tests/unit/test_projection/__init__.py` (empty file with docstring).

Create `tests/unit/test_projection/test_protocol.py` with these tests:

1. **test_protocol_compliance_refractive_model** — Construct a real `RefractiveProjectionModel` with known good params (K=identity-ish intrinsics, R=eye, t=zeros, water_z=1.0, normal=[0,0,-1], n_air=1.0, n_water=1.333). Assert `isinstance(model, ProjectionModel)` is True.

2. **test_protocol_compliance_dummy_class** — Define a `_DummyProjectionModel` class with `project(self, points: Tensor) -> tuple[Tensor, Tensor]` and `back_project(self, pixels: Tensor) -> tuple[Tensor, Tensor]` (return zeros). Assert `isinstance(dummy, ProjectionModel)` is True. This proves structural subtyping works without importing ProjectionModel.

3. **test_protocol_compliance_missing_back_project** — Define a class with only `project()`. Assert `isinstance(obj, ProjectionModel)` is False.

4. **test_protocol_compliance_missing_project** — Define a class with only `back_project()`. Assert `isinstance(obj, ProjectionModel)` is False.

Import `ProjectionModel` from `aquacore.projection` and `RefractiveProjectionModel` from `aquacore.projection`.
  </action>
  <verify>
`hatch run test tests/unit/test_projection/test_protocol.py -v` — all 4 tests pass.
  </verify>
  <done>
Protocol compliance tests verify: real model satisfies protocol, dummy class satisfies protocol (structural subtyping), and classes missing either method do not satisfy protocol. Success criterion 4 covered.
  </done>
</task>

<task type="auto">
  <name>Task 2: RefractiveProjectionModel functional and convergence tests</name>
  <files>tests/unit/test_projection/test_refractive.py</files>
  <action>
Create `tests/unit/test_projection/test_refractive.py` with a shared fixture and comprehensive tests.

**Fixture:** `model` fixture parametrized by `device` (from conftest.py device fixture). Constructs a `RefractiveProjectionModel` with realistic camera params:
- K: typical intrinsics (fx=500, fy=500, cx=320, cy=240)
- R: identity (3,3)
- t: [0, 0, 0] (camera at origin)
- water_z: 1.0 (water surface 1m below camera in +Z-down)
- normal: [0, 0, -1] (upward from water)
- n_air: 1.0, n_water: 1.333
- Move to device via `.to(device)`.

Also create an `interface` fixture returning `InterfaceParams(normal=..., water_z=1.0, n_air=1.0, n_water=1.333)` for cross-validation.

**Tests covering success criteria:**

**SC-1: project() matches Phase 1 refractive_project**
- `test_project_matches_refractive_project` — For a known underwater point (e.g., [0.2, 0.3, 1.8]), call `model.project(point)`. Separately call Phase 1 `refractive_project(point, model.C, interface)` to get interface point P, then manually project P via pinhole `K @ (R @ P + t)` with perspective division. Assert pixels match within `atol=1e-4`.

**SC-2: Round-trip convergence**
- `test_roundtrip_project_back_project` — Project a known underwater point to pixels. Back-project those pixels to (origins, directions). Reconstruct 3D point by extending ray to correct depth: `depth = (point_z - origin_z) / direction_z`, `reconstructed = origin + depth * direction`. Assert reconstructed matches original within `atol=1e-4`.
- `test_newton_raphson_residual_below_tolerance` — Project a point, back-project, reconstruct, re-project. Assert reprojected pixels match original pixels within `atol=1e-4`. This proves the NR residual f(r_p_final) is converged.

**SC-3: Batched operations**
- `test_project_batched_shapes` — Pass N=5 points (N, 3). Assert output shapes: pixels (5, 2), valid (5,).
- `test_back_project_batched_shapes` — Pass N=5 pixels (N, 2). Assert output shapes: origins (5, 3), directions (5, 3).
- `test_project_multi_shapes` — Create 3 models (M=3). Call `project_multi(models, points)` with N=5 points. Assert shapes: (3, 5, 2) pixels, (3, 5) valid.
- `test_back_project_multi_shapes` — Create 3 models. Call `back_project_multi(models, pixels)` with N=5 pixels. Assert shapes: (3, 5, 3) origins, (3, 5, 3) directions.

**Additional functional tests:**
- `test_project_invalid_above_water` — Point above water (z < water_z). Assert valid=False, pixels are NaN.
- `test_project_on_axis_point` — Point directly below camera (dx=dy=0, only depth). Should still converge (epsilon guard in r_q prevents div-by-zero). Assert valid=True.
- `test_back_project_directions_unit_length` — Assert all returned direction vectors have unit norm within 1e-5.
- `test_from_camera_matches_raw_constructor` — Create model via raw tensors. Create model via `from_camera(create_camera(intrinsics, extrinsics), interface)`. Project same point with both. Assert identical pixels.
- `test_to_device_returns_self` — Assert `model.to("cpu") is model` (returns self, mutable semantics).
- `test_to_device_moves_tensors` — After `.to("cpu")`, verify `model.K.device`, `model.K_inv.device`, `model.R.device`, `model.t.device`, `model.C.device`, `model.normal.device` are all on cpu.

Use `torch.testing.assert_close` for tensor comparisons. Parametrize device via conftest.py fixture. All CUDA tests skip cleanly without GPU.
  </action>
  <verify>
`hatch run test tests/unit/test_projection/ -v` — all tests pass.
`hatch run test` — full test suite passes (no regressions).
`hatch run check` — lint + typecheck pass.
  </verify>
  <done>
All four phase success criteria are covered by tests:
1. project() matches refractive_project (SC-1)
2. Round-trip residual below tolerance (SC-2)
3. Batched shapes correct for N points and M cameras (SC-3)
4. Protocol compliance (SC-4, from Task 1)
Plus: invalid points, on-axis convergence, from_camera factory, .to() device transfer, direction unit length.
  </done>
</task>

</tasks>

<verification>
1. `hatch run test tests/unit/test_projection/ -v` — all tests pass on CPU
2. `hatch run test` — full suite passes with no regressions
3. `hatch run check` — lint + typecheck pass across all test files
4. Test count: at minimum 16 tests (4 protocol + 12 functional)
</verification>

<success_criteria>
- Protocol compliance: positive (real model + dummy) and negative (missing methods) tests pass
- Round-trip project -> back_project recovers original 3D point within 1e-4
- Newton-Raphson convergence validated via re-projection residual
- Batched shapes verified for single-model (N points) and multi-model (M cameras x N points)
- from_camera() produces identical results to raw constructor
- .to(device) moves all tensor attributes and returns self
- All tests parametrized by device (CPU + CUDA skip)
- Full test suite passes with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/02-projection-protocol/02-02-SUMMARY.md`
</output>
