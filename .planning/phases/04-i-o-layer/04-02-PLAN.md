---
phase: 04-i-o-layer
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/aquacore/io/video.py
  - src/aquacore/io/images.py
  - src/aquacore/io/__init__.py
  - src/aquacore/__init__.py
  - tests/unit/test_io/test_videoset.py
  - tests/unit/test_io/test_factory.py
autonomous: true

must_haves:
  truths:
    - "User can construct a VideoSet from a dict of camera name to video file path and iterate frames sequentially"
    - "VideoSet __getitem__ returns dict[str, Tensor] with (C, H, W) float32 tensors in [0, 1] range"
    - "VideoSet __iter__ resets captures to frame 0 and reads sequentially (frame-exact)"
    - "VideoSet context manager releases cv2.VideoCapture handles on exit"
    - "VideoSet releases already-opened captures if constructor fails mid-init"
    - "create_frameset auto-detects directories vs video files and returns ImageSet or VideoSet"
    - "Both VideoSet and ImageSet satisfy the FrameSet protocol via isinstance check"
    - "FrameSet, VideoSet, ImageSet, create_frameset are importable from aquacore top-level"
  artifacts:
    - path: "src/aquacore/io/video.py"
      provides: "VideoSet class"
      contains: "class VideoSet"
    - path: "src/aquacore/io/images.py"
      provides: "create_frameset factory function"
      contains: "def create_frameset"
    - path: "tests/unit/test_io/test_videoset.py"
      provides: "VideoSet unit tests"
      min_lines: 80
    - path: "tests/unit/test_io/test_factory.py"
      provides: "create_frameset tests"
      min_lines: 30
  key_links:
    - from: "src/aquacore/io/video.py"
      to: "cv2.VideoCapture"
      via: "_open_captures method"
      pattern: "cv2\\.VideoCapture"
    - from: "src/aquacore/io/images.py"
      to: "src/aquacore/io/video.py"
      via: "create_frameset imports VideoSet"
      pattern: "from .video import VideoSet"
    - from: "src/aquacore/__init__.py"
      to: "src/aquacore/io/__init__.py"
      via: "top-level re-export"
      pattern: "from \\.io import"
---

<objective>
Implement VideoSet for synchronized multi-camera video access, the create_frameset factory function, and complete the public API exports.

Purpose: Delivers the second concrete FrameSet implementation (video-based workflows for AquaPose), the convenience factory function, and wires all I/O types into the top-level aquacore namespace. Completes all Phase 4 requirements (IO-01 through IO-04).

Output: Working VideoSet class, create_frameset factory, updated __init__.py files, and comprehensive tests.
</objective>

<execution_context>
@C:/Users/tucke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/tucke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-i-o-layer/04-CONTEXT.md
@.planning/phases/04-i-o-layer/04-RESEARCH.md
@.planning/phases/04-i-o-layer/04-01-SUMMARY.md
@src/aquacore/io/frameset.py
@src/aquacore/io/images.py
@src/aquacore/io/__init__.py
@src/aquacore/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: VideoSet implementation, create_frameset factory, and __init__.py exports</name>
  <files>
    src/aquacore/io/video.py
    src/aquacore/io/images.py
    src/aquacore/io/__init__.py
    src/aquacore/__init__.py
  </files>
  <action>
**video.py** — Implement VideoSet class following the research reference implementation:

1. Constructor: `__init__(self, camera_map: dict[str, str | Path])` — converts paths to `Path`, calls `_open_captures()`.
2. `_open_captures()` — validates file existence (ValueError), opens `cv2.VideoCapture` per camera. **Critical:** if any camera fails to open, release all already-opened captures before re-raising (prevent handle leak per Pitfall 4 in research). Get frame counts via `int(cap.get(cv2.CAP_PROP_FRAME_COUNT))` (cast to int per Pitfall 7). Warn on count mismatch, use minimum. Log info on success.
3. `_bgr_to_tensor(self, bgr: np.ndarray) -> torch.Tensor` — same conversion as ImageSet: `bgr[..., ::-1].copy()` then `torch.from_numpy(rgb).permute(2, 0, 1).float() / 255.0`.
4. `__getitem__(self, idx: int)` — validates index bounds, seeks each capture with `cap.set(cv2.CAP_PROP_POS_FRAMES, idx)` then `cap.read()`. Warns and omits camera on read failure.
5. `__len__` returns `self._frame_count`.
6. `__iter__` — **must reset all captures to frame 0** at start (`cap.set(cv2.CAP_PROP_POS_FRAMES, 0)` for each camera), then reads sequentially with `cap.read()`. Yields `(frame_idx, dict[str, Tensor])`. Warns and omits camera on per-frame read failure.
7. `__enter__` returns self.
8. `__exit__` — calls `cap.release()` for every capture, then clears `self._caps`.

VideoSet must NOT inherit from FrameSet. Use `warnings.warn` for data quality issues, `logging.getLogger(__name__)` for operational info.

**images.py** — Append `create_frameset` factory function at the bottom of the existing file (after ImageSet class). Add import of VideoSet: `from .video import VideoSet`. Define `_VIDEO_EXTENSIONS = {".mp4", ".avi", ".mkv", ".mov", ".wmv", ".flv"}`.

`create_frameset(camera_map: dict[str, str | Path]) -> ImageSet | VideoSet`:
- Empty map: raise ValueError
- All paths are dirs: return `ImageSet(camera_map)`
- All paths are files: return `VideoSet(camera_map)`
- Neither exist (test/mock paths): infer from extension — all video extensions -> VideoSet, no video extensions -> ImageSet
- Mixed types: raise ValueError

**io/__init__.py** — Update to export all 4 public names:
```python
from .frameset import FrameSet
from .images import ImageSet, create_frameset
from .video import VideoSet

__all__ = ["FrameSet", "ImageSet", "VideoSet", "create_frameset"]
```

**aquacore/__init__.py** — Add I/O imports to the top-level public API. Add `from .io import FrameSet, ImageSet, VideoSet, create_frameset` and add all 4 names to `__all__` in alphabetical order.
  </action>
  <verify>
Run `hatch run typecheck` — all modified files pass basedpyright.
Run `python -c "from aquacore import FrameSet, VideoSet, ImageSet, create_frameset; print('OK')"` — top-level imports work.
Run `hatch run test tests/unit/test_io/test_imageset.py` — existing ImageSet tests still pass (no regression from images.py edit).
  </verify>
  <done>
VideoSet class handles construction, validation, frame reading (seek + sequential), context manager with proper handle release, and mid-init cleanup. create_frameset auto-detects input type. All 4 public names importable from both aquacore.io and aquacore.
  </done>
</task>

<task type="auto">
  <name>Task 2: VideoSet and create_frameset tests</name>
  <files>
    tests/unit/test_io/test_videoset.py
    tests/unit/test_io/test_factory.py
  </files>
  <action>
**test_videoset.py** — Create comprehensive VideoSet tests. Use `tmp_path` to create synthetic video files with `cv2.VideoWriter`. Follow the same test patterns as test_imageset.py.

**Fixtures:**
- `two_camera_video_files(tmp_path)` — creates 2 video files ("cam0.mp4", "cam1.mp4") with 5 frames each of 480x640 synthetic BGR images (distinctive per-frame color). Uses `cv2.VideoWriter` with `cv2.VideoWriter_fourcc(*"mp4v")`. Returns `dict[str, Path]`. If mp4v codec not available, fall back to MJPG with .avi extension.

**VideoSet test cases (minimum):**

1. `test_videoset_construction` — constructs VideoSet, verifies len() matches frame count.
2. `test_videoset_getitem_returns_dict` — `vs[0]` returns dict with expected camera name keys.
3. `test_videoset_tensor_format` — each tensor is 3D, shape[0]==3, dtype==float32, values in [0, 1].
4. `test_videoset_iter_yields_tuples` — `for idx, frames in vs:` yields (int, dict) with idx 0..N-1.
5. `test_videoset_iter_all_frames` — iteration produces exactly len(vs) frames.
6. `test_videoset_iter_resets_after_getitem` — call `vs[3]`, then iterate; iteration starts at frame 0 (verifies __iter__ resets captures).
7. `test_videoset_context_manager_releases` — after `with VideoSet(...) as vs: pass`, verify captures are released (vs._caps is empty dict).
8. `test_videoset_protocol_compliance` — `isinstance(vs, FrameSet)` returns True.
9. `test_videoset_missing_file` — ValueError on nonexistent path.
10. `test_videoset_not_a_file` — ValueError when path is a directory.
11. `test_videoset_frame_count_mismatch_warns` — different frame count videos trigger warning, len() uses minimum.
12. `test_videoset_index_out_of_range` — IndexError on out-of-bounds index.
13. `test_videoset_mid_init_cleanup` — when constructor fails on 2nd camera, verify 1st camera's capture is released (create 1 valid video + 1 invalid path, catch ValueError, then try to reopen the valid video — should succeed without handle issues).

All VideoSet tests must use `with` statement (context manager) to avoid handle leaks in test teardown. Mark slow tests with `@pytest.mark.slow` if video creation takes >1s.

**test_factory.py** — Test create_frameset factory function:

1. `test_create_frameset_with_image_dirs` — passing image dirs returns ImageSet instance.
2. `test_create_frameset_with_video_files` — passing video files returns VideoSet instance.
3. `test_create_frameset_empty_map` — ValueError on empty dict.
4. `test_create_frameset_mixed_types` — ValueError when mixing dirs and files.
5. `test_create_frameset_nonexistent_video_ext` — nonexistent paths with .mp4 extension return VideoSet (extension-based inference).
6. `test_create_frameset_nonexistent_dir_ext` — nonexistent paths without video extension return ImageSet.

Use the fixtures from test_videoset.py and test_imageset.py via conftest or import. If fixtures are needed across both test files, consider a `tests/unit/test_io/conftest.py`.
  </action>
  <verify>
Run `hatch run test tests/unit/test_io/` — all tests pass (ImageSet, VideoSet, factory).
Run `hatch run test` — full suite passes with no regressions.
Run `hatch run check` — lint + typecheck passes.
  </verify>
  <done>
13+ VideoSet tests covering construction, tensor format, iteration with reset, context manager cleanup, mid-init handle release, protocol compliance, and error handling. 6+ factory tests covering auto-detection, empty map, mixed types, and extension inference. All pass alongside existing ImageSet tests.
  </done>
</task>

</tasks>

<verification>
- `hatch run check` passes (lint + typecheck)
- `hatch run test tests/unit/test_io/` passes all I/O tests (ImageSet + VideoSet + factory)
- `hatch run test` passes full suite with no regressions
- `isinstance(VideoSet({...}), FrameSet)` returns True
- `isinstance(ImageSet({...}), FrameSet)` returns True
- `from aquacore import FrameSet, VideoSet, ImageSet, create_frameset` succeeds
- VideoSet properly releases handles via context manager
</verification>

<success_criteria>
- VideoSet class implements full API: __getitem__ (seek-based), __iter__ (sequential, frame-exact with reset), __len__, __enter__, __exit__ (releases captures)
- VideoSet handles mid-init failures by releasing already-opened captures
- VideoSet returns (C, H, W) float32 [0, 1] RGB tensors
- create_frameset correctly auto-detects image dirs vs video files
- All 4 public names (FrameSet, ImageSet, VideoSet, create_frameset) importable from aquacore
- 19+ new tests pass (13 VideoSet + 6 factory)
- Full test suite passes with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/04-i-o-layer/04-02-SUMMARY.md`
</output>
