---
phase: 04-i-o-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/aquacore/io/frameset.py
  - src/aquacore/io/images.py
  - src/aquacore/io/__init__.py
  - tests/unit/test_io/__init__.py
  - tests/unit/test_io/test_imageset.py
autonomous: true

must_haves:
  truths:
    - "User can construct an ImageSet from a dict of camera name to directory path and access frames by index"
    - "ImageSet __getitem__ returns dict[str, Tensor] with (C, H, W) float32 tensors in [0, 1] range"
    - "ImageSet __iter__ yields (frame_idx, dict[str, Tensor]) tuples for all frames"
    - "ImageSet raises ValueError on missing directories, empty directories, or filename mismatches"
    - "ImageSet warns on frame count mismatch across cameras and uses minimum count"
    - "FrameSet is a runtime_checkable Protocol with __getitem__, __len__, __iter__, __enter__, __exit__"
  artifacts:
    - path: "src/aquacore/io/frameset.py"
      provides: "FrameSet runtime_checkable Protocol"
      contains: "@runtime_checkable"
    - path: "src/aquacore/io/images.py"
      provides: "ImageSet class"
      contains: "class ImageSet"
    - path: "tests/unit/test_io/test_imageset.py"
      provides: "ImageSet unit tests"
      min_lines: 80
  key_links:
    - from: "src/aquacore/io/images.py"
      to: "cv2.imread"
      via: "_read_frame_dict method"
      pattern: "cv2\\.imread"
    - from: "src/aquacore/io/images.py"
      to: "torch.from_numpy"
      via: "BGR to (C,H,W) float32 conversion"
      pattern: "torch\\.from_numpy"
---

<objective>
Implement the FrameSet protocol and ImageSet class for synchronized multi-camera image directory access.

Purpose: Establishes the I/O protocol pattern (matching Phase 2's ProjectionModel approach) and delivers the primary concrete implementation for image-based workflows. ImageSet is the simpler of the two concrete classes and validates the protocol design before VideoSet.

Output: Working FrameSet Protocol, complete ImageSet class, and comprehensive tests.
</objective>

<execution_context>
@C:/Users/tucke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/tucke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-i-o-layer/04-CONTEXT.md
@.planning/phases/04-i-o-layer/04-RESEARCH.md
@src/aquacore/projection/protocol.py
@src/aquacore/io/__init__.py
@src/aquacore/io/frameset.py
@src/aquacore/io/images.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: FrameSet Protocol and ImageSet implementation</name>
  <files>
    src/aquacore/io/frameset.py
    src/aquacore/io/images.py
    src/aquacore/io/__init__.py
  </files>
  <action>
**frameset.py** — Implement the FrameSet runtime_checkable Protocol following the exact pattern from `src/aquacore/projection/protocol.py`:

```python
@runtime_checkable
class FrameSet(Protocol):
    def __getitem__(self, idx: int) -> dict[str, torch.Tensor]: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[tuple[int, dict[str, torch.Tensor]]]: ...
    def __enter__(self) -> "FrameSet": ...
    def __exit__(self, exc_type: ..., exc_val: ..., exc_tb: ...) -> None: ...
```

Add Google-style docstrings on each method. Import `Iterator` from `typing`. The Protocol defines the contract: `__getitem__` returns `dict[str, Tensor]` (camera name to (C,H,W) float32 [0,1]), `__len__` returns frame count, `__iter__` yields `(frame_idx, dict)` tuples, context manager for resource cleanup.

**images.py** — Implement ImageSet class (do NOT add create_frameset yet — that comes in Plan 02). Follow the research reference implementation closely:

1. Constructor: `__init__(self, camera_map: dict[str, str | Path])` — converts paths to `Path`, calls `_validate_and_index()`.
2. `_validate_and_index()` — validates directory existence (ValueError if not), globs image files using both-case extensions `("*.png", "*.PNG", "*.jpg", "*.JPG", "*.jpeg", "*.JPEG", "*.tiff", "*.TIFF", "*.tif", "*.TIF", "*.bmp", "*.BMP")`, raises ValueError on empty dirs, enforces matching filenames across cameras (ValueError on mismatch), warns on frame count mismatch (use minimum), logs info on success.
3. `_read_frame_dict(self, idx: int) -> dict[str, torch.Tensor]` — reads each camera's image via `cv2.imread`, converts BGR to RGB tensor: `bgr[..., ::-1].copy()` then `torch.from_numpy(rgb).permute(2, 0, 1).float() / 255.0`. Warns and omits camera on read failure.
4. `__getitem__`, `__len__`, `__iter__` per locked API decisions.
5. `__enter__` returns self, `__exit__` is no-op (no resources to release).

ImageSet must NOT inherit from FrameSet — structural typing only. Use `warnings.warn` for data quality issues (stacklevel=2 for init, stacklevel=3 for read helpers). Use `logging.getLogger(__name__)` for operational info.

**io/__init__.py** — Export FrameSet and ImageSet (not create_frameset or VideoSet yet):
```python
from .frameset import FrameSet
from .images import ImageSet

__all__ = ["FrameSet", "ImageSet"]
```

Do NOT update the top-level `aquacore/__init__.py` yet — that happens in Plan 02 when all exports are ready.
  </action>
  <verify>
Run `hatch run typecheck` — frameset.py and images.py must pass basedpyright.
Run `python -c "from aquacore.io import FrameSet, ImageSet; print('OK')"` — imports succeed.
  </verify>
  <done>
FrameSet Protocol is defined with all 5 required methods. ImageSet class handles construction, validation, indexing, iteration, and context manager. Both are importable from aquacore.io.
  </done>
</task>

<task type="auto">
  <name>Task 2: ImageSet tests</name>
  <files>
    tests/unit/test_io/__init__.py
    tests/unit/test_io/test_imageset.py
  </files>
  <action>
Create `tests/unit/test_io/__init__.py` (empty).

Create `tests/unit/test_io/test_imageset.py` with comprehensive tests. Use `tmp_path` pytest fixture to create synthetic image directories with `cv2.imwrite`. Follow test patterns from `tests/unit/test_undistortion.py`.

**Fixtures:**
- `two_camera_image_dirs(tmp_path)` — creates 2 camera dirs ("cam0", "cam1") with 5 synthetic 480x640 BGR PNG images each (distinctive per-frame color so values can be verified). Returns `dict[str, Path]`.
- `single_camera_image_dir(tmp_path)` — one camera, 3 frames. Returns `dict[str, Path]`.

**Test cases (minimum):**

1. `test_imageset_construction` — constructs ImageSet, verifies `len()` matches frame count.
2. `test_imageset_getitem_returns_dict` — `img_set[0]` returns dict with expected camera name keys.
3. `test_imageset_tensor_format` — each tensor is 3D, shape[0]==3, dtype==float32, values in [0, 1].
4. `test_imageset_tensor_values` — verify BGR-to-RGB conversion is correct: write a known BGR image (e.g., pure blue BGR = [255, 0, 0]), read back, confirm tensor channel 2 (blue in RGB) has value ~1.0 and channels 0,1 are ~0.0.
5. `test_imageset_iter_yields_tuples` — `for idx, frames in img_set:` yields (int, dict) with correct idx sequence 0..N-1.
6. `test_imageset_iter_all_frames` — iteration produces exactly `len(img_set)` frames.
7. `test_imageset_context_manager` — `with ImageSet(...) as s:` works and returns the same object.
8. `test_imageset_protocol_compliance` — `isinstance(img_set, FrameSet)` returns True.
9. `test_imageset_missing_directory` — ValueError on nonexistent path.
10. `test_imageset_empty_directory` — ValueError on dir with no images.
11. `test_imageset_filename_mismatch` — ValueError when camera dirs have different filenames.
12. `test_imageset_frame_count_mismatch_warns` — different frame counts across cameras triggers warning, len() uses minimum.
13. `test_imageset_index_out_of_range` — IndexError on negative or too-large index.
14. `test_imageset_independent_copies` — reading same frame twice returns tensors that don't share memory (`t1.data_ptr() != t2.data_ptr()`).

Use `pytest.raises` for error tests, `pytest.warns(UserWarning)` for warning tests.
  </action>
  <verify>
Run `hatch run test tests/unit/test_io/test_imageset.py` — all tests pass.
Run `hatch run test` — full suite still passes (no regressions).
  </verify>
  <done>
14+ tests covering ImageSet construction, tensor format, BGR-to-RGB conversion, iteration, context manager, protocol compliance, error handling, and memory independence. All pass.
  </done>
</task>

</tasks>

<verification>
- `hatch run typecheck` passes for all modified files
- `hatch run test tests/unit/test_io/` passes all ImageSet tests
- `hatch run test` passes full suite with no regressions
- `isinstance(ImageSet({...}), FrameSet)` returns True
</verification>

<success_criteria>
- FrameSet Protocol is defined in frameset.py with @runtime_checkable and all 5 methods
- ImageSet class implements full API: __getitem__, __len__, __iter__, __enter__, __exit__
- ImageSet returns (C, H, W) float32 [0, 1] RGB tensors (BGR conversion verified by test)
- ImageSet validates inputs: missing dirs, empty dirs, filename mismatches all raise ValueError
- ImageSet warns on frame count mismatch and uses minimum
- 14+ tests pass covering all behaviors
</success_criteria>

<output>
After completion, create `.planning/phases/04-i-o-layer/04-01-SUMMARY.md`
</output>
