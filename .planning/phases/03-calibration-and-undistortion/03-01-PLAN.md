---
phase: 03-calibration-and-undistortion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/aquacore/calibration.py
  - src/aquacore/__init__.py
  - tests/unit/test_calibration.py
autonomous: true

must_haves:
  truths:
    - "User can call load_calibration_data with a file path and get a CalibrationData object"
    - "User can call load_calibration_data with a pre-parsed dict and get a CalibrationData object"
    - "CalibrationData.cameras returns dict[str, CameraData] with typed intrinsics, extrinsics fields"
    - "CameraData composes Phase 1 CameraIntrinsics and CameraExtrinsics types"
    - "CalibrationData stores a single global water_z and an InterfaceParams object"
    - "aquacore is importable with AquaCal uninstalled (no AquaCal import anywhere)"
    - "Bad camera entries are skipped with a warning, not a crash"
  artifacts:
    - path: "src/aquacore/calibration.py"
      provides: "CameraData, CalibrationData dataclasses and load_calibration_data function"
      contains: "class CameraData"
    - path: "tests/unit/test_calibration.py"
      provides: "Tests for loader, validation, edge cases"
      contains: "def test_load"
  key_links:
    - from: "src/aquacore/calibration.py"
      to: "src/aquacore/types.py"
      via: "CameraData composes CameraIntrinsics, CameraExtrinsics, InterfaceParams"
      pattern: "from .types import"
    - from: "src/aquacore/__init__.py"
      to: "src/aquacore/calibration.py"
      via: "Public API exports"
      pattern: "from .calibration import"
---

<objective>
Implement CameraData, CalibrationData dataclasses and load_calibration_data() function that parses AquaCal JSON directly (no AquaCal dependency).

Purpose: CAL-01 and CAL-02 -- users can load calibration files into typed Python objects that compose Phase 1 types.
Output: Working calibration.py with loader + comprehensive tests.
</objective>

<execution_context>
@C:/Users/tucke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/tucke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/aquacore/types.py
@src/aquacore/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement CameraData, CalibrationData, and load_calibration_data</name>
  <files>src/aquacore/calibration.py, src/aquacore/__init__.py</files>
  <action>
Replace the stub in calibration.py with the full implementation. Reference AquaMVS's calibration.py (at ../AquaMVS/src/aquamvs/calibration.py) as the pattern but with these divergences per user decisions:

**CameraData dataclass:**
- `name: str` -- camera identifier from JSON key
- `intrinsics: CameraIntrinsics` -- composes Phase 1 type (not raw K/dist_coeffs)
- `extrinsics: CameraExtrinsics` -- composes Phase 1 type (not raw R/t)
- `is_auxiliary: bool = False`

**CalibrationData dataclass:**
- `cameras: dict[str, CameraData]` -- keyed by camera name
- `interface: InterfaceParams` -- reuses Phase 1 type (stores normal, water_z, n_air, n_water)
- Property `camera_list: list[CameraData]` -- ordered list (insertion order from JSON)
- Method `core_cameras() -> dict[str, CameraData]` -- cameras where is_auxiliary=False
- Method `auxiliary_cameras() -> dict[str, CameraData]` -- cameras where is_auxiliary=True

Note: water_z is stored in `interface.water_z` (InterfaceParams already has this field). Extract water_z from the first valid camera entry in the JSON. The CalibrationData does NOT have a separate water_z field -- it lives in interface.

**load_calibration_data(source: str | Path | dict) -> CalibrationData:**
- If str/Path: json.load() the file. If dict: use directly.
- Parse `cameras` section: for each camera entry, extract intrinsics (K, dist_coeffs, image_size, is_fisheye) into CameraIntrinsics, extrinsics (R, t) into CameraExtrinsics.
- Normalize t shape from (3,1) to (3,) silently (known AquaCal quirk).
- K as float32, dist_coeffs as float64 (per project convention from Phase 1).
- R as float32, t as float32.
- Parse `interface` section into InterfaceParams. Set water_z from first valid camera's `water_z` or `interface_distance` (backward compat).
- Support backward compat: `interface_distance` as old name for `water_z` in camera entries.
- Check `version` field: warn on unknown version (via `warnings.warn()`) but attempt to load.
- Required fields per camera: intrinsics (K, dist_coeffs, image_size), extrinsics (R, t), water_z/interface_distance. Optional: is_fisheye (default False), is_auxiliary (default False).
- If a camera entry is missing a required field: skip that camera with `warnings.warn()`, do NOT fail the entire load.
- If no valid cameras remain after skipping: raise ValueError.
- Silently ignore optional top-level sections: board, diagnostics, metadata.
- NO AquaCal imports anywhere in the file. Use only json (stdlib), warnings (stdlib), torch, pathlib.

**Update __init__.py:**
- Add imports: `from .calibration import CalibrationData, CameraData, load_calibration_data`
- Add to __all__: "CalibrationData", "CameraData", "load_calibration_data"
  </action>
  <verify>
Run `hatch run typecheck` to confirm type correctness. Run `python -c "from aquacore import CalibrationData, CameraData, load_calibration_data; print('OK')"` to confirm imports work.
  </verify>
  <done>
calibration.py contains CameraData, CalibrationData, and load_calibration_data with no AquaCal imports. All three are importable from aquacore. Type checker passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Comprehensive tests for calibration loader</name>
  <files>tests/unit/test_calibration.py</files>
  <action>
Create test_calibration.py with tests using synthetic JSON data (no real calibration files needed). Build test fixtures as Python dicts that mirror the AquaCal JSON schema.

**Fixture: valid calibration dict** (use as pytest fixture):
```python
{
    "version": "1.0",
    "cameras": {
        "cam0": {
            "intrinsics": {"K": [[500,0,320],[0,500,240],[0,0,1]], "dist_coeffs": [0.1,-0.2,0.001,0.002,0.03], "image_size": [640, 480]},
            "extrinsics": {"R": [[1,0,0],[0,1,0],[0,0,1]], "t": [0.0, 0.0, 0.0]},
            "water_z": 0.15
        },
        "cam1": {
            "intrinsics": {"K": [[600,0,320],[0,600,240],[0,0,1]], "dist_coeffs": [0.05,-0.1,0.0,0.0,0.01], "image_size": [640, 480]},
            "extrinsics": {"R": [[0.9,0.0,0.436],[0.0,1.0,0.0],[-0.436,0.0,0.9]], "t": [0.5, 0.0, 0.0]},
            "water_z": 0.15,
            "is_auxiliary": true
        }
    },
    "interface": {"normal": [0,0,-1], "n_air": 1.0, "n_water": 1.333}
}
```

**Test cases:**
1. `test_load_from_dict` -- load from dict, check cameras dict has 2 entries, CameraData fields are correct types
2. `test_load_from_file` -- write dict to tmp_path JSON, load from Path, same result
3. `test_load_from_str_path` -- load from str path (not Path object)
4. `test_camera_data_composes_phase1_types` -- verify intrinsics is CameraIntrinsics, extrinsics is CameraExtrinsics
5. `test_camera_data_name` -- verify CameraData.name matches JSON key
6. `test_K_dtype_float32` -- verify K is float32
7. `test_dist_coeffs_dtype_float64` -- verify dist_coeffs is float64
8. `test_R_dtype_float32` -- verify R and t are float32
9. `test_t_shape_normalization` -- provide t as [[0.1],[0.2],[0.3]] (3,1 shape), verify loaded as shape (3,)
10. `test_interface_params` -- verify interface is InterfaceParams with correct normal, water_z, n_air, n_water
11. `test_water_z_from_first_camera` -- verify interface.water_z == first camera's water_z value
12. `test_is_fisheye_default_false` -- omit is_fisheye, verify defaults to False
13. `test_is_fisheye_true` -- set is_fisheye: true with 4 dist_coeffs, verify is_fisheye=True
14. `test_is_auxiliary` -- verify cam1 is_auxiliary=True, cam0 is_auxiliary=False
15. `test_core_cameras` -- verify core_cameras() returns only non-auxiliary cameras
16. `test_auxiliary_cameras` -- verify auxiliary_cameras() returns only auxiliary cameras
17. `test_camera_list` -- verify camera_list returns list of CameraData in insertion order
18. `test_backward_compat_interface_distance` -- use "interface_distance" instead of "water_z", verify loads correctly
19. `test_unknown_version_warns` -- set version to "2.0", verify UserWarning issued but load succeeds
20. `test_missing_camera_field_skips_with_warning` -- one camera missing "extrinsics", verify it's skipped with warning, other camera loads fine
21. `test_all_cameras_invalid_raises` -- all cameras missing required fields, verify ValueError raised
22. `test_ignores_optional_sections` -- add board, diagnostics, metadata sections, verify they're silently ignored
23. `test_missing_cameras_section_raises` -- no "cameras" key, verify ValueError
24. `test_missing_interface_section_raises` -- no "interface" key, verify ValueError
25. `test_file_not_found` -- load from nonexistent path, verify FileNotFoundError

Use `pytest.warns(UserWarning)` for warning tests. Use `tmp_path` fixture for file-based tests.
  </action>
  <verify>
Run `hatch run test tests/unit/test_calibration.py -v` -- all tests pass.
  </verify>
  <done>
All 25 test cases pass. Loader handles valid input, edge cases (t shape, backward compat, fisheye), error cases (missing fields, bad files), and warning cases (unknown version, skipped cameras).
  </done>
</task>

</tasks>

<verification>
- `hatch run test tests/unit/test_calibration.py -v` -- all tests pass
- `hatch run typecheck` -- no type errors in calibration.py
- `hatch run lint` -- no lint issues
- `python -c "from aquacore import load_calibration_data, CalibrationData, CameraData"` -- imports work
- No `aquacal` or `from aquacal` appears anywhere in src/aquacore/calibration.py
</verification>

<success_criteria>
- load_calibration_data accepts str, Path, or dict and returns CalibrationData
- CameraData composes CameraIntrinsics and CameraExtrinsics from Phase 1
- CalibrationData stores InterfaceParams with global water_z
- Bad cameras skipped with warning, not crash
- All 25 tests pass
- No AquaCal dependency
</success_criteria>

<output>
After completion, create `.planning/phases/03-calibration-and-undistortion/03-01-SUMMARY.md`
</output>
