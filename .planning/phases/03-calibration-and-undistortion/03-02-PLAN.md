---
phase: 03-calibration-and-undistortion
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/aquacore/undistortion.py
  - src/aquacore/__init__.py
  - tests/unit/test_undistortion.py
autonomous: true

must_haves:
  truths:
    - "User can call compute_undistortion_maps with a CameraData object and get a (map_x, map_y) NumPy tuple"
    - "Pinhole and fisheye cameras produce different undistortion maps via correct OpenCV dispatch"
    - "User can call undistort_image with a PyTorch tensor and get back a PyTorch tensor on the same device"
    - "undistort_image output matches the input image shape"
  artifacts:
    - path: "src/aquacore/undistortion.py"
      provides: "compute_undistortion_maps and undistort_image functions"
      contains: "def compute_undistortion_maps"
    - path: "tests/unit/test_undistortion.py"
      provides: "Tests for undistortion pipeline"
      contains: "def test_"
  key_links:
    - from: "src/aquacore/undistortion.py"
      to: "src/aquacore/calibration.py"
      via: "Imports CameraData for type annotation"
      pattern: "from .calibration import CameraData"
    - from: "src/aquacore/undistortion.py"
      to: "cv2"
      via: "OpenCV undistortion map computation and remap"
      pattern: "cv2.initUndistortRectifyMap|cv2.fisheye.initUndistortRectifyMap|cv2.remap"
---

<objective>
Implement compute_undistortion_maps() and undistort_image() in undistortion.py with pinhole/fisheye dispatch and PyTorch tensor I/O.

Purpose: CAL-03 and CAL-04 -- users can compute undistortion maps from calibration data and undistort images as PyTorch tensors.
Output: Working undistortion.py with both functions + comprehensive tests.
</objective>

<execution_context>
@C:/Users/tucke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/tucke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-calibration-and-undistortion/03-01-SUMMARY.md
@src/aquacore/calibration.py
@src/aquacore/types.py
@src/aquacore/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement compute_undistortion_maps and undistort_image</name>
  <files>src/aquacore/undistortion.py, src/aquacore/__init__.py</files>
  <action>
Replace the stub in undistortion.py with the full implementation. Reference AquaMVS's calibration.py (compute_undistortion_maps and undistort_image at ../AquaMVS/src/aquamvs/calibration.py) as the pattern but with these divergences per user decisions:

**compute_undistortion_maps(camera_data: CameraData) -> tuple[np.ndarray, np.ndarray]:**
- Accepts CameraData directly (not separate K, dist_coeffs, etc.)
- Returns raw `(map_x, map_y)` NumPy tuple -- NO UndistortionData wrapper (per user decision)
- Extract K, dist_coeffs, image_size from camera_data.intrinsics
- Convert K to float64 numpy: `camera_data.intrinsics.K.cpu().numpy().astype(np.float64)`
- Convert dist_coeffs to float64 numpy: `camera_data.intrinsics.dist_coeffs.cpu().numpy().astype(np.float64)`
- Dispatch on `camera_data.intrinsics.is_fisheye`:
  - **Fisheye path:** reshape dist_coeffs to (4,1) for cv2.fisheye. Use `cv2.fisheye.estimateNewCameraMatrixForUndistortRectify(K, D, image_size, np.eye(3))` then `cv2.fisheye.initUndistortRectifyMap(K, D, np.eye(3), K_new, image_size, cv2.CV_32FC1)`.
  - **Pinhole path:** Use `cv2.getOptimalNewCameraMatrix(K, dist, image_size, alpha=0, newImgSize=image_size)` then `cv2.initUndistortRectifyMap(K, dist, None, K_new, image_size, cv2.CV_32FC1)`.
- image_size is already (width, height) from CameraIntrinsics -- pass directly to OpenCV (OpenCV expects (w, h)).

**undistort_image(image: torch.Tensor, maps: tuple[np.ndarray, np.ndarray]) -> torch.Tensor:**
- Accepts PyTorch tensor image and (map_x, map_y) tuple from compute_undistortion_maps
- Image tensor expected shape: (H, W, 3) or (H, W) uint8 -- same as what VideoSet/ImageSet will produce
- Convert to NumPy: `image.detach().cpu().numpy()`
- Apply `cv2.remap(img_np, map_x, map_y, cv2.INTER_LINEAR)`
- Convert back: `torch.from_numpy(result).to(image.device)`
- Return tensor on same device as input (follows project OpenCV boundary pattern)

**Imports needed:** `from __future__ import annotations`, `import cv2`, `import numpy as np`, `import torch`, `from .calibration import CameraData`

**Update __init__.py:**
- Add imports: `from .undistortion import compute_undistortion_maps, undistort_image`
- Add to __all__: "compute_undistortion_maps", "undistort_image"
  </action>
  <verify>
Run `hatch run typecheck` to confirm type correctness. Run `python -c "from aquacore import compute_undistortion_maps, undistort_image; print('OK')"` to confirm imports work.
  </verify>
  <done>
undistortion.py contains both functions. compute_undistortion_maps dispatches pinhole/fisheye correctly. undistort_image handles PyTorch tensor round-trip. Both importable from aquacore.
  </done>
</task>

<task type="auto">
  <name>Task 2: Tests for undistortion pipeline</name>
  <files>tests/unit/test_undistortion.py</files>
  <action>
Create test_undistortion.py. Since undistortion is an OpenCV wrapper, tests verify correct dispatch, tensor I/O, shapes, and dtypes rather than pixel-perfect output.

**Helper fixture: create CameraData objects for testing.** Build CameraData from CameraIntrinsics + CameraExtrinsics directly (no JSON loading needed). Example pinhole camera:
```python
CameraData(
    name="test_pinhole",
    intrinsics=CameraIntrinsics(
        K=torch.tensor([[500.0,0,320],[0,500,240],[0,0,1]], dtype=torch.float32),
        dist_coeffs=torch.tensor([0.1, -0.2, 0.001, 0.002, 0.03], dtype=torch.float64),
        image_size=(640, 480),
        is_fisheye=False,
    ),
    extrinsics=CameraExtrinsics(
        R=torch.eye(3, dtype=torch.float32),
        t=torch.zeros(3, dtype=torch.float32),
    ),
    is_auxiliary=False,
)
```

**Test cases for compute_undistortion_maps:**
1. `test_pinhole_maps_shape` -- maps are (H, W) = (480, 640) float32 ndarray
2. `test_pinhole_maps_dtype` -- both map_x and map_y are np.float32
3. `test_fisheye_maps_shape` -- same shape check with is_fisheye=True, 4 dist_coeffs
4. `test_fisheye_maps_dtype` -- both maps are np.float32
5. `test_returns_tuple` -- return type is tuple of length 2
6. `test_maps_contain_valid_coordinates` -- map_x values mostly within [0, width], map_y within [0, height] (not all NaN/inf)

**Test cases for undistort_image:**
7. `test_output_shape_matches_input` -- (480, 640, 3) in, (480, 640, 3) out
8. `test_output_dtype_uint8` -- input uint8, output uint8
9. `test_output_device_matches_input` -- output tensor is on same device as input
10. `test_grayscale_image` -- (480, 640) single-channel works too
11. `test_identity_distortion` -- zero dist_coeffs, undistorted == original (pixel values match within tolerance for remap interpolation)

**Integration test (still unit-level, no files):**
12. `test_roundtrip_pinhole` -- create CameraData, compute maps, undistort a synthetic image tensor, verify output shape and device
13. `test_roundtrip_fisheye` -- same for fisheye camera

Use `@pytest.fixture` for pinhole_camera and fisheye_camera CameraData objects. Use `torch.randint(0, 255, (480, 640, 3), dtype=torch.uint8)` for synthetic images.
  </action>
  <verify>
Run `hatch run test tests/unit/test_undistortion.py -v` -- all tests pass.
  </verify>
  <done>
All 13 test cases pass. Maps have correct shape/dtype. undistort_image preserves shape, dtype, and device. Both pinhole and fisheye paths work.
  </done>
</task>

</tasks>

<verification>
- `hatch run test tests/unit/test_undistortion.py -v` -- all tests pass
- `hatch run test` -- full test suite still passes (no regressions)
- `hatch run typecheck` -- no type errors
- `hatch run lint` -- no lint issues
- `python -c "from aquacore import compute_undistortion_maps, undistort_image"` -- imports work
</verification>

<success_criteria>
- compute_undistortion_maps accepts CameraData and returns (map_x, map_y) NumPy tuple
- Pinhole and fisheye dispatch works via is_fisheye flag
- undistort_image accepts and returns PyTorch tensors, converts internally for cv2.remap
- Output tensor is on same device as input tensor
- All 13 tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-calibration-and-undistortion/03-02-SUMMARY.md`
</output>
