---
phase: 01-foundation-and-physics-math
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/aquacore/types.py
  - src/aquacore/interface.py
  - src/aquacore/transforms.py
  - src/aquacore/__init__.py
  - tests/conftest.py
  - tests/unit/test_types.py
  - tests/unit/test_transforms.py
  - tests/unit/test_interface.py
autonomous: true

must_haves:
  truths:
    - "User can import CameraIntrinsics, CameraExtrinsics, InterfaceParams, Vec2, Vec3, Mat3 from aquacore and construct instances with typed fields"
    - "User can convert rotation vectors to rotation matrices and back, matching cv2.Rodrigues output to 1e-5"
    - "User can compose two poses and invert a pose; the result is mathematically correct"
    - "User can compute camera center from extrinsics as C = -R.T @ t"
    - "User can compute ray-plane intersection for a flat air-water interface"
    - "All tests parametrize over CPU and CUDA devices via a shared conftest fixture"
  artifacts:
    - path: "src/aquacore/types.py"
      provides: "CameraIntrinsics, CameraExtrinsics, InterfaceParams, Vec2, Vec3, Mat3, coordinate constants"
      contains: "class CameraIntrinsics"
    - path: "src/aquacore/interface.py"
      provides: "ray_plane_intersection"
      contains: "def ray_plane_intersection"
    - path: "src/aquacore/transforms.py"
      provides: "rvec_to_matrix, matrix_to_rvec, compose_poses, invert_pose, camera_center"
      contains: "def rvec_to_matrix"
    - path: "src/aquacore/__init__.py"
      provides: "Public API re-exports"
      contains: "CameraIntrinsics"
    - path: "tests/conftest.py"
      provides: "device fixture parametrizing CPU and CUDA"
      contains: "def device"
  key_links:
    - from: "src/aquacore/__init__.py"
      to: "src/aquacore/types.py"
      via: "from .types import"
      pattern: "from \\.types import"
    - from: "src/aquacore/__init__.py"
      to: "src/aquacore/transforms.py"
      via: "from .transforms import"
      pattern: "from \\.transforms import"
    - from: "tests/unit/test_transforms.py"
      to: "tests/conftest.py"
      via: "device fixture"
      pattern: "def test_.*device"
---

<objective>
Implement foundation types (CameraIntrinsics, CameraExtrinsics, InterfaceParams, Vec2, Vec3, Mat3), the ray-plane intersection function, all transform utilities (Rodrigues, pose composition, pose inversion, camera center), and the shared test device fixture.

Purpose: This is the dependency root — every other Phase 1 module imports from types.py, and every test uses the device fixture from conftest.py. Nothing else can start until these exist.

Output: Working types.py, interface.py, transforms.py with full test coverage on CPU and CUDA.
</objective>

<execution_context>
@C:/Users/tucke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/tucke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-and-physics-math/01-RESEARCH.md
@.planning/phases/01-foundation-and-physics-math/01-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement types.py, interface.py, transforms.py, and update __init__.py</name>
  <files>
    src/aquacore/types.py
    src/aquacore/interface.py
    src/aquacore/transforms.py
    src/aquacore/__init__.py
  </files>
  <action>
**types.py** — Implement all foundation types (requirements TYPE-01 through TYPE-05):

1. Type aliases using `TypeAlias`:
   - `Vec2: TypeAlias = torch.Tensor`  (document shape `(2,)` or `(N, 2)`)
   - `Vec3: TypeAlias = torch.Tensor`  (document shape `(3,)` or `(N, 3)`)
   - `Mat3: TypeAlias = torch.Tensor`  (document shape `(3, 3)`)

2. Dataclasses:
   - `CameraIntrinsics` with fields: `K: torch.Tensor` (3,3 float32), `dist_coeffs: torch.Tensor` (N, float64 — OpenCV requires float64), `image_size: tuple[int, int]` (width, height), `is_fisheye: bool = False`
   - `CameraExtrinsics` with fields: `R: torch.Tensor` (3,3 float32), `t: torch.Tensor` (3, float32). Add `@property C` returning `-R.T @ t` (camera center).
   - `InterfaceParams` with fields: `normal: torch.Tensor` (3, float32), `water_z: float`, `n_air: float = 1.0`, `n_water: float = 1.333`

3. Coordinate system constants (TYPE-05):
   - `INTERFACE_NORMAL = torch.tensor([0.0, 0.0, -1.0])` — upward from water surface per CLAUDE.md convention
   - Document coordinate system in module docstring: world origin at reference camera, +X right, +Y forward, +Z down into water. Camera frame: OpenCV convention. Extrinsics: `p_cam = R @ p_world + t`.

**interface.py** — Implement ray-plane intersection (REF-05):

```python
def ray_plane_intersection(
    origins: torch.Tensor,      # (N, 3)
    directions: torch.Tensor,   # (N, 3) unit vectors
    plane_normal: torch.Tensor, # (3,)
    plane_d: float,             # signed distance from origin (water_z for flat interface)
) -> tuple[torch.Tensor, torch.Tensor]:
```
Returns `(points, valid)` where `points` is `(N, 3)` intersection points and `valid` is `(N,)` bool (False when ray is parallel to plane). Use `t = (plane_d - dot(origin, normal)) / dot(direction, normal)`. Return valid=False when `abs(denom) < 1e-12`. Points with `t < 0` (behind ray) should also be marked invalid.

**transforms.py** — Implement all transform utilities (TRN-01 through TRN-04):

1. `rvec_to_matrix(rvec: torch.Tensor) -> torch.Tensor`: Pure-PyTorch Rodrigues formula. Handle edge cases: `||rvec|| < 1e-10` returns identity. Use formula: `R = cos(θ)*I + sin(θ)*K + (1-cos(θ))*k⊗k` where K is skew-symmetric matrix of unit axis k. See Research Pattern 8.

2. `matrix_to_rvec(R: torch.Tensor) -> torch.Tensor`: Inverse Rodrigues. `θ = arccos(clamp((trace(R)-1)/2, -1, 1))`. For `θ < 1e-10`: return zeros. For `θ > π - 1e-6`: use special-case `k_i = sqrt((R[i,i]+1)/2)` (see Pitfall 5 in research). Normal case: extract axis from `(R - R.T) / (2*sin(θ))`.

3. `compose_poses(R1, t1, R2, t2) -> tuple[torch.Tensor, torch.Tensor]`: Returns `(R2 @ R1, R2 @ t1 + t2)`. All tensors float32.

4. `invert_pose(R, t) -> tuple[torch.Tensor, torch.Tensor]`: Returns `(R.T, -R.T @ t)`.

5. `camera_center(R, t) -> torch.Tensor`: Returns `-R.T @ t` (same as CameraExtrinsics.C property but standalone).

**__init__.py** — Update public API:
- Import and re-export: `CameraIntrinsics`, `CameraExtrinsics`, `InterfaceParams`, `Vec2`, `Vec3`, `Mat3`, `INTERFACE_NORMAL` from types
- Import and re-export: `ray_plane_intersection` from interface
- Import and re-export: `rvec_to_matrix`, `matrix_to_rvec`, `compose_poses`, `invert_pose`, `camera_center` from transforms
- Update `__all__` list

Do NOT add `create_camera` to `__init__.py` yet (Plan 02).
  </action>
  <verify>
Run `hatch run typecheck` — no errors in types.py, interface.py, transforms.py.
Run `python -c "from aquacore import CameraIntrinsics, CameraExtrinsics, InterfaceParams, Vec2, Vec3, Mat3, rvec_to_matrix"` — imports succeed.
  </verify>
  <done>
All types, interface function, and transform functions are implemented. Public API exports work. Typecheck passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create conftest.py device fixture and write tests for types, interface, and transforms</name>
  <files>
    tests/conftest.py
    tests/unit/test_types.py
    tests/unit/test_transforms.py
    tests/unit/test_interface.py
  </files>
  <action>
**tests/conftest.py** — Create the shared device fixture (QA-02):

```python
import pytest
import torch

@pytest.fixture(params=[
    "cpu",
    pytest.param("cuda", marks=pytest.mark.skipif(
        not torch.cuda.is_available(), reason="CUDA not available"
    )),
])
def device(request):
    return torch.device(request.param)
```

This fixture is used by ALL geometry tests to parametrize over CPU and CUDA. No test should ever call `.cuda()` directly.

**tests/unit/test_types.py** — Test foundation types (TYPE-01..05, QA-01):

1. `test_camera_intrinsics_construction(device)`: Create CameraIntrinsics with K, dist_coeffs, image_size. Assert fields stored correctly, K on correct device.
2. `test_camera_extrinsics_construction(device)`: Create CameraExtrinsics with R=eye(3), t=zeros(3). Assert R, t on correct device.
3. `test_camera_extrinsics_center(device)`: Create extrinsics with known R, t. Assert C property returns `-R.T @ t`. Use `torch.testing.assert_close`.
4. `test_interface_params_defaults()`: Create InterfaceParams, assert n_air=1.0, n_water=1.333 defaults.
5. `test_interface_normal_convention()`: Assert `INTERFACE_NORMAL` is `[0, 0, -1]`.

**tests/unit/test_transforms.py** — Test all transforms (TRN-01..04, QA-01):

1. `test_rvec_to_matrix_zero(device)`: Zero rvec produces identity matrix.
2. `test_rvec_to_matrix_90_z(device)`: rvec = `[0, 0, pi/2]` produces 90-degree rotation about Z. Verify R @ [1,0,0] ≈ [0,1,0].
3. `test_rvec_to_matrix_180(device)`: rvec = `[pi, 0, 0]` produces 180-degree rotation about X. Verify R @ [0,1,0] ≈ [0,-1,0]. Tests Pitfall 5 edge case.
4. `test_matrix_to_rvec_roundtrip(device)`: Generate random rvec, convert to matrix, convert back. Assert `||rvec_out|| == ||rvec_in||` and direction matches (or is negated for θ > π ambiguity). Use `torch.testing.assert_close(atol=1e-5, rtol=0)`.
5. `test_compose_poses(device)`: Compose identity pose with a known pose. Result equals the known pose.
6. `test_compose_poses_known_values(device)`: Compose two non-trivial poses. Verify manually computed result.
7. `test_invert_pose(device)`: Invert a pose, then compose with original. Result should be identity (R=I, t=0).
8. `test_camera_center(device)`: Known R, t. Assert `camera_center(R, t)` matches `-R.T @ t`.

**tests/unit/test_interface.py** — Test ray-plane intersection (REF-05, QA-01):

1. `test_ray_hits_plane(device)`: Ray from (0,0,-1) direction (0,0,1), plane at z=0. Intersection at (0,0,0).
2. `test_ray_parallel_to_plane(device)`: Ray direction parallel to plane normal. valid=False.
3. `test_ray_behind_origin(device)`: Ray pointing away from plane. valid=False (t < 0).
4. `test_batched_intersection(device)`: N=5 rays, mix of valid and invalid. Verify correct valid mask and intersection points.

All tests use `torch.testing.assert_close(atol=1e-5, rtol=0)` for float comparisons. All tests accept `device` fixture parameter.
  </action>
  <verify>
Run `hatch run test tests/unit/test_types.py tests/unit/test_transforms.py tests/unit/test_interface.py -v` — all tests pass.
Run `hatch run lint` — no lint errors in test files.
  </verify>
  <done>
All foundation types, transforms, and interface tests pass on CPU (and CUDA if available). Device fixture is shared via conftest.py. No test imports AquaCal or AquaMVS. No test uses hardcoded `.cuda()`.
  </done>
</task>

</tasks>

<verification>
1. `hatch run test tests/unit/test_types.py tests/unit/test_transforms.py tests/unit/test_interface.py -v` — all pass
2. `hatch run typecheck` — no errors in types.py, interface.py, transforms.py
3. `python -c "from aquacore import CameraIntrinsics, Vec3, rvec_to_matrix, ray_plane_intersection"` — imports succeed
4. `hatch run lint` — clean
</verification>

<success_criteria>
- CameraIntrinsics, CameraExtrinsics, InterfaceParams constructable with typed fields
- Vec2, Vec3, Mat3 type aliases importable
- INTERFACE_NORMAL equals [0, 0, -1]
- rvec_to_matrix round-trips with matrix_to_rvec to 1e-5
- compose_poses and invert_pose are mathematically correct (compose + invert = identity)
- ray_plane_intersection returns correct points and valid mask
- All tests parametrize over device fixture
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-physics-math/01-01-SUMMARY.md`
</output>
