---
phase: 01-foundation-and-physics-math
plan: 03
type: tdd
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/aquacore/refraction.py
  - src/aquacore/triangulation.py
  - src/aquacore/__init__.py
  - tests/unit/test_refraction.py
  - tests/unit/test_triangulation.py
autonomous: true

must_haves:
  truths:
    - "User can call snells_law_3d with a batch of rays and get correctly refracted directions satisfying the sin-ratio law"
    - "Total internal reflection returns valid=False, not NaN"
    - "User can trace rays from air through interface into water and from water into air"
    - "User can call refractive_project to find the interface point for an underwater 3D point seen by an air-side camera"
    - "User can call refractive_back_project to cast a refracted ray from a pixel into water"
    - "User can triangulate a 3D point from N rays and the result matches known ground truth"
    - "point_to_ray_distance reports correct reprojection error"
    - "Triangulation works with refractive rays (TRI-03 integration)"
  artifacts:
    - path: "src/aquacore/refraction.py"
      provides: "snells_law_3d, trace_ray_air_to_water, trace_ray_water_to_air, refractive_project, refractive_back_project"
      contains: "def snells_law_3d"
    - path: "src/aquacore/triangulation.py"
      provides: "triangulate_rays, point_to_ray_distance"
      contains: "def triangulate_rays"
    - path: "tests/unit/test_refraction.py"
      provides: "Known-value Snell's law tests, TIR test, ray tracing tests"
      contains: "def test_normal_incidence"
    - path: "tests/unit/test_triangulation.py"
      provides: "Known-value triangulation tests, refractive triangulation integration test"
      contains: "def test_triangulate_two_rays"
  key_links:
    - from: "src/aquacore/refraction.py"
      to: "src/aquacore/interface.py"
      via: "imports ray_plane_intersection"
      pattern: "from .interface import"
    - from: "src/aquacore/refraction.py"
      to: "src/aquacore/types.py"
      via: "imports InterfaceParams"
      pattern: "from .types import"
    - from: "tests/unit/test_triangulation.py"
      to: "src/aquacore/refraction.py"
      via: "TRI-03 integration: refractive rays fed into triangulate_rays"
      pattern: "snells_law_3d|trace_ray"
---

<objective>
Implement Snell's law (3D vector form), refractive ray tracing, Newton-Raphson refractive projection/back-projection, batched triangulation, and point-to-ray distance. Includes the TRI-03 integration test proving refractive rays triangulate correctly.

Purpose: These are the core physics functions that the Projection Protocol (Phase 2) and calibration (Phase 3) build on. Snell's law and triangulation are the two most algorithmically complex components in Phase 1.

Output: Working refraction.py and triangulation.py with full known-value test coverage on CPU and CUDA.
</objective>

<execution_context>
@C:/Users/tucke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/tucke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-and-physics-math/01-RESEARCH.md
@.planning/phases/01-foundation-and-physics-math/01-CONTEXT.md
@.planning/phases/01-foundation-and-physics-math/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement refraction.py and triangulation.py</name>
  <files>
    src/aquacore/refraction.py
    src/aquacore/triangulation.py
    src/aquacore/__init__.py
  </files>
  <action>
**refraction.py** — Implement all refraction functions (REF-01 through REF-04, REF-06, REF-07):

Import from aquacore: `InterfaceParams` from types, `ray_plane_intersection` from interface.

1. **`snells_law_3d(incident_directions, surface_normal, n_ratio)` (REF-01, REF-02):**
   - `incident_directions`: (N, 3) unit vectors
   - `surface_normal`: (3,) unit normal
   - `n_ratio`: float (n_incident / n_transmitted)
   - Returns `(directions, valid)`: (N, 3) refracted unit vectors, (N,) bool mask
   - Implementation: See Research Pattern 5 exactly. Key steps:
     - `cos_i = dot(d, normal)` per ray
     - Orient normal: if cos_i < 0, flip normal (ray going against normal)
     - `sin_t_sq = n_ratio^2 * (1 - cos_i^2)`
     - `valid = sin_t_sq <= 1.0` (REF-02: TIR detection)
     - `cos_t = sqrt(clamp(1 - sin_t_sq, min=0))` (clamp for numerical stability)
     - `d_refracted = n_ratio * d + (cos_t - n_ratio * cos_i) * n_oriented`
     - Normalize, zero out TIR directions
   - **Do NOT return None for TIR** — return (zeros, False) per user decision

2. **`trace_ray_air_to_water(origins, directions, interface)` (REF-03):**
   - `origins`: (N, 3) ray origins (camera centers, in air)
   - `directions`: (N, 3) unit ray directions (from camera into scene)
   - `interface`: InterfaceParams
   - Steps: (a) intersect ray with plane at water_z using `ray_plane_intersection`, (b) apply `snells_law_3d` with n_ratio = n_air/n_water at intersection
   - Returns `(interface_points, refracted_directions, valid)`: (N,3), (N,3), (N,) bool

3. **`trace_ray_water_to_air(origins, directions, interface)` (REF-04):**
   - Same as above but n_ratio = n_water/n_air. Origins are underwater points.

4. **`refractive_project(points, camera_center, interface, n_iterations=10)` (REF-06):**
   - `points`: (N, 3) underwater 3D points
   - `camera_center`: (3,) camera center in world frame (in air)
   - `interface`: InterfaceParams
   - Returns `(interface_points, valid)`: (N, 3) points on water surface, (N,) bool
   - Implementation: Newton-Raphson from Research Pattern 6. Key steps:
     - Compute horizontal distance r_q from camera to underwater point (in XY plane)
     - Compute heights h_c (camera above water) and h_q (point below water)
     - Initial guess: `r_p = r_q * h_c / (h_c + h_q + 1e-12)`
     - Fixed 10 iterations (per user decision — no convergence check, for autograd):
       - `f = n_air * sin(θ_air) - n_water * sin(θ_water)` (Snell's law residual)
       - `f' = derivative of f w.r.t. r_p`
       - `r_p = r_p - f / (f' + 1e-12)` (epsilon for numerical stability, Pitfall 2)
       - `r_p = clamp(r_p, min=0)` and `r_p = min(r_p, r_q)` (non-in-place ops for autograd)
     - Convert r_p back to 3D interface point on the water surface
   - Handle edge case: points directly below camera (r_q ≈ 0) — add epsilon to avoid div-by-zero

5. **`refractive_back_project(pixel_rays, camera_centers, interface)` (REF-07):**
   - `pixel_rays`: (N, 3) unit ray directions from camera (in air, world frame)
   - `camera_centers`: (N, 3) or (3,) camera centers
   - `interface`: InterfaceParams
   - Returns `(interface_points, water_directions, valid)`: intersection points on surface, refracted directions in water, validity mask
   - Implementation: wrapper around `trace_ray_air_to_water`

**triangulation.py** — Implement triangulation (TRI-01, TRI-02):

Import from aquacore: none needed (pure torch).

1. **`triangulate_rays(rays)` (TRI-01):**
   - `rays`: list of tuples `(origin, direction)`, each (3,) tensors
   - Returns (3,) point — midpoint minimizing sum of squared distances to all rays
   - Implementation: See Research Pattern 7 exactly. Closed-form linear system:
     - `A_sum = sum(I - d @ d.T)` for each ray
     - `b_sum = sum((I - d @ d.T) @ origin)` for each ray
     - `P = torch.linalg.solve(A_sum, b_sum)`
   - Catch `torch.linalg.LinAlgError` and raise `ValueError("Degenerate ray configuration")` (Pitfall 4)
   - Infer device from first ray's origin tensor

2. **`point_to_ray_distance(point, ray_origin, ray_direction)` (TRI-02):**
   - All inputs: (3,) tensors
   - Returns scalar tensor — perpendicular distance from point to ray
   - Formula: `||v - (v . d) * d||` where `v = point - origin`, `d = unit direction`

**__init__.py** — Add exports:
- From refraction: `snells_law_3d`, `trace_ray_air_to_water`, `trace_ray_water_to_air`, `refractive_project`, `refractive_back_project`
- From triangulation: `triangulate_rays`, `point_to_ray_distance`
- Update `__all__`
  </action>
  <verify>
Run `hatch run typecheck` — no errors in refraction.py, triangulation.py.
Run `python -c "from aquacore import snells_law_3d, triangulate_rays, refractive_project"` — imports succeed.
  </verify>
  <done>
All refraction and triangulation functions implemented. Snell's law handles TIR with valid mask. Newton-Raphson uses fixed iterations with epsilon guards. Triangulation uses closed-form linear solve. All exported from __init__.py.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write known-value tests for refraction and triangulation including TRI-03 integration</name>
  <files>
    tests/unit/test_refraction.py
    tests/unit/test_triangulation.py
  </files>
  <action>
**tests/unit/test_refraction.py** — Test all refraction functions (REF-01..07, QA-01, QA-02):

**Snell's law tests:**

1. `test_normal_incidence(device)`: Ray (0,0,1) into normal (0,0,-1), n_ratio=1/1.333. At normal incidence, direction unchanged: (0,0,1). Valid=True.

2. `test_known_angle_30deg(device)`: Ray at 30 degrees from vertical into water. `sin(30°) = 0.5`, n_ratio=1/1.333. Expected `sin(θ_water) = 0.5/1.333 ≈ 0.3751`. Verify the X-component of the refracted ray matches this sin value. Valid=True.

3. `test_known_angle_45deg(device)`: Ray at 45 degrees. `sin(45°)/1.333 ≈ 0.5303`. Verify sin ratio.

4. `test_total_internal_reflection(device)`: Water-to-air with steep angle. n_ratio=1.333/1.0, angle > critical angle (critical angle ≈ 48.6° for n=1.333). Use 60° incidence. Assert valid=False.

5. `test_critical_angle_boundary(device)`: Angle exactly at critical angle. `sin(θ_c) = 1/1.333 ≈ 0.7502`. Assert valid=True (just barely).

6. `test_batch_mixed_validity(device)`: Batch of 3 rays — one normal, one refracted, one TIR. Verify correct valid mask per ray.

7. `test_snells_law_satisfies_ratio(device)`: For arbitrary valid refraction, verify `n1 * sin(θ1) == n2 * sin(θ2)` within tolerance. This is the physics invariant.

**Ray tracing tests:**

8. `test_trace_air_to_water_vertical(device)`: Vertical ray from (0,0,-1) direction (0,0,1), water at z=0. Should hit (0,0,0) and continue straight down (no refraction at normal incidence).

9. `test_trace_air_to_water_angled(device)`: Angled ray from camera above water. Verify interface point is on the water surface (z = water_z) and refracted direction satisfies Snell's law.

10. `test_trace_water_to_air(device)`: Ray from (0,0,1) direction (0,0,-1), water at z=0. Verify correct refraction from water to air.

**Refractive projection tests:**

11. `test_refractive_project_on_axis(device)`: Point directly below camera at (0, 0, water_z + depth). Interface point should be at (0, 0, water_z) — no horizontal displacement.

12. `test_refractive_project_off_axis(device)`: Point offset horizontally. Verify interface point is between camera and underwater point (horizontally). Verify it lies on the water surface.

13. `test_refractive_project_convergence(device)`: Project a point, then verify the Snell's law residual at the found interface point is < 1e-6. This tests Newton-Raphson convergence.

**Refractive back-projection tests:**

14. `test_refractive_back_project_vertical(device)`: Vertical ray from camera above water. Should pass straight through (normal incidence).

15. `test_refractive_back_project_consistency(device)`: Back-project a pixel ray, get interface point and water direction. Then trace from underwater point back using water-to-air. The two paths should be consistent (same interface point).

**tests/unit/test_triangulation.py** — Test triangulation (TRI-01..03, QA-01, QA-02):

**Basic triangulation:**

1. `test_triangulate_two_rays_known_point(device)`: Two rays from known origins, intersecting at (0, 0, 5). Ray 1: origin (1, 0, 0), direction toward (0, 0, 5). Ray 2: origin (-1, 0, 0), direction toward (0, 0, 5). Assert result ≈ (0, 0, 5) within 1e-5.

2. `test_triangulate_three_rays(device)`: Three rays from different positions all targeting same point. Should improve accuracy.

3. `test_triangulate_noisy_rays(device)`: Add small noise to directions. Result should still be close to ground truth (within noise level).

4. `test_triangulate_degenerate_parallel(device)`: Two parallel rays. Assert raises `ValueError` with "Degenerate" in message.

**Point-to-ray distance:**

5. `test_point_on_ray(device)`: Point lies exactly on ray. Distance should be 0.

6. `test_point_off_ray_known_distance(device)`: Point at (1, 0, 0), ray from origin along Z-axis. Distance = 1.0.

7. `test_point_to_ray_batch_consistency(device)`: Triangulate a point, then verify point_to_ray_distance from that point to each input ray is small (< 0.01).

**TRI-03 Integration (refractive triangulation):**

8. `test_refractive_triangulation_integration(device)`:
   - Place a known 3D underwater point at (0.5, 0.5, 1.5) with water_z=0.
   - Two cameras above water at (-1, 0, -1) and (1, 0, -1).
   - For each camera: compute the direction from camera to known point, then use `trace_ray_air_to_water` to get the refracted ray in water (the interface point becomes the new ray origin, refracted direction becomes ray direction).
   - Feed these refractive rays into `triangulate_rays`.
   - Assert the triangulated point matches the known underwater point within 0.01 (relaxed tolerance due to refraction).
   - This is the end-to-end test proving refraction + triangulation work together.

All tests use `device` fixture. Use `torch.testing.assert_close(atol=..., rtol=0)` for comparisons.
  </action>
  <verify>
Run `hatch run test tests/unit/test_refraction.py tests/unit/test_triangulation.py -v` — all tests pass.
Run `hatch run lint tests/unit/` — clean.
  </verify>
  <done>
Snell's law satisfies the sin-ratio invariant for known angles. TIR returns valid=False. Ray tracing works air-to-water and water-to-air. Newton-Raphson converges (residual < 1e-6). Triangulation recovers known 3D points. Refractive triangulation integration test passes. All tests on CPU/CUDA.
  </done>
</task>

</tasks>

<verification>
1. `hatch run test tests/unit/test_refraction.py tests/unit/test_triangulation.py -v` — all pass
2. `hatch run test tests/unit/ -v` — ALL phase 1 tests pass together (including types, transforms, interface from Plan 01)
3. `hatch run typecheck` — no errors
4. `hatch run lint` — clean
5. Verify no test file imports from aquacal or aquamvs: `grep -r "import aquacal\|import aquamvs\|from aquacal\|from aquamvs" tests/` returns nothing
</verification>

<success_criteria>
- snells_law_3d produces correct refracted rays verified against known sin-ratio values
- Total internal reflection returns valid=False, never NaN
- trace_ray_air_to_water and trace_ray_water_to_air produce physically correct results
- refractive_project Newton-Raphson converges (residual < 1e-6) in 10 fixed iterations
- triangulate_rays recovers known 3D point from two or more rays
- point_to_ray_distance is correct for known geometry
- Refractive triangulation integration test passes (TRI-03)
- All tests parametrize over CPU/CUDA device fixture
- No test imports AquaCal or AquaMVS
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-physics-math/01-03-SUMMARY.md`
</output>
