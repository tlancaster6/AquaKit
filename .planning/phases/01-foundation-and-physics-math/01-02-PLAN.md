---
phase: 01-foundation-and-physics-math
plan: 02
type: tdd
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/aquacore/camera.py
  - src/aquacore/__init__.py
  - tests/unit/test_camera.py
autonomous: true

must_haves:
  truths:
    - "User can create a pinhole camera via create_camera() with is_fisheye=False and project 3D points to 2D pixels"
    - "User can back-project 2D pixels to 3D rays using pinhole camera"
    - "Pinhole camera handles radial and tangential distortion via OpenCV"
    - "User can create a fisheye camera via create_camera() with is_fisheye=True and project 3D points to 2D pixels"
    - "User can back-project 2D pixels to 3D rays using fisheye camera"
    - "create_camera() validates inputs and raises on device mismatch"
    - "Round-trip project then back-project recovers original ray direction to 1e-5"
  artifacts:
    - path: "src/aquacore/camera.py"
      provides: "_PinholeCamera, _FisheyeCamera, create_camera factory"
      contains: "def create_camera"
    - path: "tests/unit/test_camera.py"
      provides: "Known-value tests for pinhole and fisheye projection and back-projection"
      contains: "def test_pinhole_project"
  key_links:
    - from: "src/aquacore/camera.py"
      to: "src/aquacore/types.py"
      via: "imports CameraIntrinsics, CameraExtrinsics"
      pattern: "from .types import"
    - from: "src/aquacore/__init__.py"
      to: "src/aquacore/camera.py"
      via: "from .camera import create_camera"
      pattern: "from \\.camera import"
---

<objective>
Implement pinhole and fisheye camera models with project/back-project operations, and the create_camera() factory function. Both models use OpenCV for distortion at the NumPy boundary.

Purpose: Camera models are required by refraction (REF-06, REF-07) and are the primary user-facing geometry primitive. The create_camera() factory is the only public construction API per user decision.

Output: Working camera.py with pinhole and fisheye cameras, round-trip tested on CPU and CUDA.
</objective>

<execution_context>
@C:/Users/tucke/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/tucke/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-and-physics-math/01-RESEARCH.md
@.planning/phases/01-foundation-and-physics-math/01-CONTEXT.md
@.planning/phases/01-foundation-and-physics-math/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement camera.py with pinhole, fisheye, and create_camera factory</name>
  <files>
    src/aquacore/camera.py
    src/aquacore/__init__.py
  </files>
  <action>
**camera.py** — Implement camera models (CAM-01 through CAM-06):

Import types from `aquacore.types`: `CameraIntrinsics`, `CameraExtrinsics`.

**`_PinholeCamera` class (internal):**

Constructor takes `CameraIntrinsics` and `CameraExtrinsics`. Store R, t, K, dist_coeffs, image_size as attributes.

`project(self, points: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor]`:
- `points`: (N, 3) world-frame, float32
- Transform to camera frame: `p_cam = (R @ points.T).T + t` — shape (N, 3)
- Mark valid: `p_cam[:, 2] > 0`
- Apply distortion via OpenCV boundary: convert K, dist_coeffs, p_cam to numpy float64, call `cv2.projectPoints(p_cam_np, rvec=np.zeros(3), tvec=np.zeros(3), cameraMatrix=K_np, distCoeffs=dist_np)`, convert result back to torch on original device
- Return `(pixels, valid)` where pixels is (N, 2)

`pixel_to_ray(self, pixels: torch.Tensor) -> torch.Tensor`:
- `pixels`: (N, 2) pixel coordinates, float32
- Undistort via OpenCV: convert to numpy, call `cv2.undistortPoints(pixels_np, K_np, dist_np)` to get normalized camera-frame points (x, y)
- Construct 3D ray in camera frame: `[x, y, 1]`, normalize to unit
- Rotate to world frame: `rays_world = (R.T @ rays_cam.T).T`
- Return (N, 3) unit direction vectors

**`_FisheyeCamera` class (internal):**

Same interface as `_PinholeCamera` but uses `cv2.fisheye.projectPoints` and `cv2.fisheye.undistortPoints`.

`project(self, points: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor]`:
- Same world-to-camera transform
- Use `cv2.fisheye.projectPoints(p_cam_np, rvec=np.zeros(3), tvec=np.zeros(3), K=K_np, D=dist_np)` — note: cv2.fisheye uses `D` not `distCoeffs`
- Return `(pixels, valid)`

`pixel_to_ray(self, pixels: torch.Tensor) -> torch.Tensor`:
- Use `cv2.fisheye.undistortPoints(pixels_np, K_np, dist_np)` to get normalized points
- Same ray construction and rotation to world frame

**`create_camera()` factory (CAM-06):**

```python
def create_camera(
    intrinsics: CameraIntrinsics,
    extrinsics: CameraExtrinsics,
) -> _PinholeCamera | _FisheyeCamera:
```

- **Validate at boundary per user decision:**
  - Check intrinsics.K.device == extrinsics.R.device == extrinsics.t.device. If mismatch, raise `ValueError` with clear message listing devices.
  - Check K shape is (3, 3), R shape is (3, 3), t shape is (3,)
  - Check dist_coeffs is 1D
- Dispatch on `intrinsics.is_fisheye`: True returns `_FisheyeCamera`, False returns `_PinholeCamera`

**Important implementation notes:**
- OpenCV calls are CPU-only — always `.cpu().numpy()` before cv2, `.to(device)` after. Document this in class docstring: "project() and pixel_to_ray() are NOT differentiable due to OpenCV CPU round-trip."
- dist_coeffs MUST be float64 for OpenCV (Pitfall 1 from research)
- Both project() and pixel_to_ray() use batch (N, 3) / (N, 2) shapes — not single-point

**__init__.py** — Add `create_camera` to imports and `__all__`:
```python
from .camera import create_camera
```
  </action>
  <verify>
Run `hatch run typecheck` — no errors in camera.py.
Run `python -c "from aquacore import create_camera"` — import succeeds.
  </verify>
  <done>
create_camera() factory dispatches correctly. Both _PinholeCamera and _FisheyeCamera implement project() and pixel_to_ray(). Input validation raises on device mismatch.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write camera model tests with known-value and round-trip verification</name>
  <files>tests/unit/test_camera.py</files>
  <action>
**tests/unit/test_camera.py** — Test camera models (CAM-01..06, QA-01, QA-02):

Create shared fixtures:
- `pinhole_intrinsics(device)`: CameraIntrinsics with K=[[500,0,320],[0,500,240],[0,0,1]], dist_coeffs=zeros(5), image_size=(640,480), is_fisheye=False
- `fisheye_intrinsics(device)`: CameraIntrinsics with K=[[500,0,320],[0,500,240],[0,0,1]], dist_coeffs=zeros(4), image_size=(640,480), is_fisheye=True
- `identity_extrinsics(device)`: CameraExtrinsics with R=eye(3), t=zeros(3)

**Pinhole tests:**

1. `test_pinhole_project_on_axis(device)`: Point at (0, 0, 5) in world frame with identity extrinsics. Expected pixel: (320, 240) — principal point. Use `torch.testing.assert_close(atol=1e-3, rtol=0)`.

2. `test_pinhole_project_off_axis(device)`: Point at (1, 0, 5). Expected pixel x = 500*1/5 + 320 = 420. Assert pixel ≈ (420, 240).

3. `test_pinhole_behind_camera(device)`: Point at (0, 0, -5). Assert valid=False.

4. `test_pinhole_pixel_to_ray(device)`: Pixel (320, 240) — principal point. Expected ray direction: (0, 0, 1) in camera frame, which is (0, 0, 1) in world frame with identity extrinsics.

5. `test_pinhole_round_trip(device)`: Project a 3D point, then back-project the resulting pixel to a ray. The ray direction should point from camera center toward the original 3D point. Verify `angle(ray, expected_direction) < 1e-5 radians`.

6. `test_pinhole_with_distortion(device)`: Create intrinsics with non-zero k1=-0.1 (barrel distortion). Project and back-project. Round-trip should still recover ray direction to within 1e-4.

**Fisheye tests:**

7. `test_fisheye_project_on_axis(device)`: Point at (0, 0, 5) with identity extrinsics. Expected pixel: (320, 240).

8. `test_fisheye_pixel_to_ray(device)`: Pixel (320, 240). Expected ray: (0, 0, 1).

9. `test_fisheye_round_trip(device)`: Same as pinhole round-trip but using fisheye camera. Tolerance 1e-4.

**Factory tests:**

10. `test_create_camera_dispatches_pinhole(device)`: create_camera with is_fisheye=False returns _PinholeCamera (check type name contains "Pinhole").

11. `test_create_camera_dispatches_fisheye(device)`: create_camera with is_fisheye=True returns _FisheyeCamera.

12. `test_create_camera_device_mismatch()`: Pass K on CPU, R on "meta" device (or different). Assert raises ValueError with "device" in message. Skip if only CPU available — use `torch.tensor(..., device="meta")` for the mismatch since "meta" device is always available.

All tests use `device` fixture from conftest.py. Use `torch.testing.assert_close` for comparisons.
  </action>
  <verify>
Run `hatch run test tests/unit/test_camera.py -v` — all tests pass.
Run `hatch run lint tests/unit/test_camera.py` — clean.
  </verify>
  <done>
Pinhole and fisheye cameras project correctly to known pixel values. Round-trip project → back-project recovers ray direction within tolerance. create_camera() dispatches correctly and validates inputs. All tests parametrized over CPU/CUDA.
  </done>
</task>

</tasks>

<verification>
1. `hatch run test tests/unit/test_camera.py -v` — all pass
2. `hatch run typecheck` — no errors
3. `hatch run lint` — clean
4. Round-trip test verifies project → back-project recovers ray to 1e-5
</verification>

<success_criteria>
- create_camera() creates pinhole camera when is_fisheye=False
- create_camera() creates fisheye camera when is_fisheye=True
- Pinhole project() maps on-axis point to principal point
- Pinhole pixel_to_ray() maps principal point to forward ray
- Round-trip project → back-project matches to 1e-5 for both models
- Device mismatch raises ValueError
- All tests use device fixture (CPU + CUDA)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-physics-math/01-02-SUMMARY.md`
</output>
